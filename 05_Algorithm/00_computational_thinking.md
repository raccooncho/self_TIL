### 0. 기초

* p -> q

  * 명제 : p 이면 q이다.
  * 역 : q 이면 p이다.
  * 이 : p가 아니면, q도 아니다.
  * 대우 : q가 아니면 p도 아니다.
  * **대우가 참이면 명제도 참이다**

* 관련된 기호

  | ~p         | p ∧ q                                        | p ∨ q                                               | ∀x              | ∃x              |
  | ---------- | -------------------------------------------- | --------------------------------------------------- | --------------- | --------------- |
  | p가 아니다 | p와 q의 교집합 ( and / 둘다 참이어야 참이다) | p와 q의 합집합 ( or / 둘중 하나만 참이어도 참이다.) | 모든 x에 대해서 | 어떤 x에 대해서 |

* 수학적 귀납법과 증명 수준

  * 기본형 : P[1]이 참이고, P[n] -> P[n + 1]이 참이면 P[n]은 모든 자연수 n에 대해서 참이다.
  * 강한 형태 : P[1]이 참이고, P[1] ^ P[2] ^ P[3] ^ ... ^ P[n] -> P[n + 1]이 참이면 P[n]은 모든 자연수 n에 대해서 참이다.



### 1. 논리와 증명

* 진리표를 이용해 증명 ( 이건 하기 너무나 귀찮은 것..)

* 직접 증명

  * 예제 ) n이 짝수이면 3n + 5는 홀수임을 증명하라

    ```
    모든 짝수n은 자연수 k에 대해 n = 2k로 표현할 수 있음.
    따라서 3n + 5 = 3(2k) + 5 = 6k + 5로 전환이 가능하고
    6k + 5 = 2(3k + 2) + 1이므로 2m + 1의 형태, 즉 홀수임이 증명된다.
    ```

* 대우를 증명

  * 예제 ) 자연수 n에 대해, n² + 5가 홀수이면 n은 짝수임을 증명하라

    ```
    주어진 명제의 대우는 n이 홀수이면 n² + 5는 짝수이다 이다.
    자연수 k에 대해 홀수 n은 2k - 1 로 표현할 수 있고 n² + 5는 (2k - 1)² + 5로 변경 가능하다. 
    위 식을 풀이하면 4k² - 4k + 1 + 6 = 2(2k² - 2k + 3) 즉, 2m의 형태로 변경이 가능하므로 짝수임이 증명이 된다.
    따라서 대우가 참이므로 명제 n이 홀수이면 n² + 5는 짝수이다는 참이다.
    ```

* 경우를 나누어 증명

  * 예제 ) 자연수 n 에 대해 n² + 5n + 3은 항상 홀수임을 증명하라.

    ```
    모든 자연수 k에 대해서
    1. n = 2k인 경우(짝수)
    	n² + 5n + 3 = 4k² + 10n + 3 = 2(2k² + 5k + 1) + 1이므로 항상 홀수이다.
    2. n = 2k - 1인 경우(홀수)
    	n² + 5n + 3 = 4k² - 4k + 1 + 10k - 5 + 3 = 2(2k² + 3k - 1) + 1이므로 항상 홀수이다.
    ```



### 2. 수와 표현

* 기본적인 log표현
  * x = log ~2~ n ==> 2^x^ = n
  * log ~a~ b = log ~c~ b / log ~c~ a
  * log ~a~ b = 1 / log ~b~ a
  * log ~a~ xy = log ~a~ x + log ~a~ y
  * log ~a~ x^k^ = k log ~a~ x
  * log ~a~ (x / y) = log ~a~ x - log ~a~ y
  * a ^ log ~c~ b = b ^ log ~c~ b 
  * log ~a^m~ b^n^ = (n / m) log ~a~ b

* 기본적으로 log n이 나오려면
  * 1 + (1/2 + 1/2) + (1/4 + 1/4 + 1/4 + 1/4) + ... + (1/n + 1/n + ... + 1/n) = log n
  * 반절씩 줄어드는 과정은 O( log n )으로 표현될 수 있다. (1 대신 n씩 더해진다면 O(n log n))



### 3. 집합과 조합론

* 집합 A = {x | x = 2k + 1, k는 자연수}와 집합 B = {x | x = 4k + 1 or x = 4k + 3, k는 자연수}가 동일함을 증명하기 위해선 

  * A가 B의 부분집합인 경우와 

  * B가 A의 부분집합인 경우를 나눠서 증명하면 된다.

    ```
    1. A가 B의 부분집합인 경우
    	A에 속하는 임의의 원소 x를 가정
    	x = 2k + 1
    	1) k가 홀수인 경우
    		x = 2(2m - 1) + 1 = 4m - 1 = 4(m-1) + 3
    	2) k가 짝수인 경우
    		x = 2 * 2m + 1 = 4m + 1
        따라서 A에 속하는 임의의 원소 x는 모든 경우에 B에 포함됨
    
    2. B가 A의 부분집합인 경우
    	B에 속하는 임의의 원소 x를 가정
    	1) x = 4k + 1인 경우
    		x = 2(2k) + 1 
        2) x = 4k + 3인 경우
        	x = 2(2k + 1) + 1
        따라서 B에 속하는 임의의 원소 x는 모든 경우에 A에 포함됨
    A는 B의 부분집합에 해당하고 B도 A의 부분집합에 해당하므로 A와 B는 같다.
    ```

* 조합 ~n~C~r~ = 

  ​		( n )

  ​		( r )처럼 괄호로 표현할 수 있음.



### 4. 기초 수식

* 시간 복잡도 O()를 구하는 문제....

* 재귀 식의 시간 복잡도를 구할 수 있어야 한다.

  ```
  T(n) = T(n - 1) + 1
  	= T(n - 2) + 1 + 1
  	= T(1) + 1 + ... + 1
  
  T(n) = O(n)
  ```

  

### 5. 재귀

* 수학적 귀납법으로 n = 0 혹은 n = 1일 때 문제를 해결할 수 있고, 

* n-1에서 문제를 풀 수 있으면 n에서도 문제를 해결할 수 있을 때 

* 모든 가능한 n(n >= 0 or n >=1)에 대해서 문제를 풀 수 있음이 성립한다.

* 예시 ) 피보나치 수열 F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

  ```python
  def fibo(n):
      if n <= 2: return 1
      return fibo(n-1) + fibo(n-2)
  ```

  ```
  위 식에서
  T(n) = T(n-1) + T(n-2) + 1
  	 < 2 T(n-1) + 1이므로
  	 2^n 만큼 식이 진행된다.
  따라서, T(n) = O(2^n)
  ```



### 6. 동적 프로그래밍

* 문제해결의 심화 단계

  * 반복문 -> 재귀함수 -> memorization -> dynamic programming

* Memorization

  * 재귀 함수에서 동일한 입력의 호출이 반복적으로 일어날 때, 그 결과값을 저장해 두어 필요없는 호출을 방지하는 방법이다.

  ```python
  memo = [0 for _ in range(100)]
  def fibo(n):
      if memo[n] != 0:
          return memo[n]
      if n <= 2:
          memo[n] = 1
          return 1
      memo[n] = fibo(n-1) + fibo(n-2)
      return memo[n]
  ```

  * 시간복잡도 T(n) = O(n^2)이다.

* 반복 알고리즘으로 해결할 수도 있다.

  ```python
  memo = [0 for _ in range(100)]
  memo[0] = memo[1] = 1
  def fibo(n):
      for i in range(2, n):
          memo[i] = memo[i-1] + memo[i-2]
      return memo[n-1] + memo[n-2]
  ```

  * 한번의 반복문으로 memo 리스트를 완성하고 답을 출력하기 때문에 T(n) = O(n)이다. ( 단, 여러번 반복해서 답을 출력해야 할 경우에는 위의 memorization이 더 좋을 수 있을 것 같다.)